# -*- coding: utf-8 -*-
"""Slider_line_angle.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o0E4P65ZNm1pdLuUsENmLw0Yzue9qjhB
"""

!gcloud auth login

!gcloud storage cp -r gs://orthlyml-playground/evangelos/etc/packages .

weight_beta = 1.0
weight_gamma = 1.0 # 1.0 propagates changes to a wider area, 3.0 to more narrow

# @title
from google.colab import output
output.enable_custom_widget_manager()

import os
import numpy as np
opacity=1.0
outdir = 'packages'

path = os.path.join(outdir, f"package_{weight_beta}_{weight_gamma}.npy")
package = np.load(path, allow_pickle=True).item()
Vcomb1 = package['Vcomb1']
F0 = package['F0']
meshes = package['meshes']

import plotly.graph_objects as go
import ipywidgets as widgets
from IPython.display import display
# -------------------------------------------------
# 2. Helper: Open3D mesh -> Plotly Mesh3d kwargs
# -------------------------------------------------
def mesh_to_plotly_kwargs(mesh):
    verts = mesh
    faces = F0#np.asarray(mesh.triangles)

    return dict(
        x = verts[:, 0],
        y = verts[:, 1],
        z = verts[:, 2],
        i = faces[:, 0],
        j = faces[:, 1],
        k = faces[:, 2],
    )

# -------------------------------------------------
# 3. Create a single-Scene FigureWidget with 2 traces
# -------------------------------------------------
kwargs_A0 = mesh_to_plotly_kwargs(Vcomb1)
kwargs_B0 = mesh_to_plotly_kwargs(meshes[0][0])

trace_A = go.Mesh3d(
    **kwargs_A0,
    name="Mesh A",
    color="lightblue",
    # --- LIGHTING ---
    lighting=dict(
        ambient=0.4,
        diffuse=0.9,
        specular=0.5,
        roughness=0.3,
        fresnel=0.1,
    ),
    lightposition=dict(
        x=0,
        y=0,
        z=-1.0  # light from above
    ),
    flatshading=False,
    opacity=opacity,
    showscale=False,
)


trace_B = go.Mesh3d(
    **kwargs_B0,
    name="Mesh B",
    color="lightblue",

    # --- LIGHTING ---
    lighting=dict(
        ambient=0.4,
        diffuse=0.9,
        specular=0.5,
        roughness=0.3,
        fresnel=0.1,
    ),
    lightposition=dict(
        x=0,
        y=0,
        z=-30.0  # light from above
    ),
    flatshading=False,
    opacity=opacity,
                showscale=False,
)


fig = go.FigureWidget(
    data=[trace_A, trace_B],
    layout=go.Layout(
        width=400,
        height=400,
        scene=dict(
            aspectmode="data",
            xaxis=dict(visible=False),
            yaxis=dict(visible=False),
            zaxis=dict(visible=False),
        ),
        margin=dict(l=0, r=0, t=0, b=0),
            scene_camera=dict(
            eye=dict(x=-0.002, y=-0.018, z=2.135),
            center=dict(x=0, y=0, z=0),
            up=dict(x=0, y=0, z=1),
        )
    )
)


# -------------------------------------------------
# 4. Slider + callback updating BOTH meshes
# -------------------------------------------------
slider = widgets.IntSlider(
    value=0,
    min=0,
    max=len(meshes) - 1,
    step=1,
    description="Step",
    continuous_update=True,
)

def on_slider_change(change):
    idx = change["new"]

    #kA = mesh_to_plotly_kwargs(meshes_A[idx])
    kB = mesh_to_plotly_kwargs(meshes[idx][0])

    with fig.batch_update():
        # Mesh A (trace 0)
        """
        fig.data[0].x = kA["x"]
        fig.data[0].y = kA["y"]
        fig.data[0].z = kA["z"]
        fig.data[0].i = kA["i"]
        fig.data[0].j = kA["j"]
        fig.data[0].k = kA["k"]
        """

        # Mesh B (trace 1)
        fig.data[1].x = kB["x"]
        fig.data[1].y = kB["y"]
        fig.data[1].z = kB["z"]
        fig.data[1].i = kB["i"]
        fig.data[1].j = kB["j"]
        fig.data[1].k = kB["k"]

        fig.layout.title = f"Step {idx}"

slider.observe(on_slider_change, names="value")

display(widgets.VBox([slider, fig]))
