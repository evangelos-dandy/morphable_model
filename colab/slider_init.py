# -*- coding: utf-8 -*-
"""Slider_init.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Z6Wd9ELWTBm0JxlO7fhY6EOzBo19VAA3
"""

import numpy as np
import open3d as o3d
import os

import joblib

import numpy as np
import plotly.graph_objs as go
from ipywidgets import FloatSlider, VBox, HBox, Button

from IPython.display import display

if not os.path.exists("saved_models"):
    os.makedirs("saved_models")

from sklearn.decomposition import PCA
pca_path = "pca_model.pkl"
if os.path.exists(pca_path):
    pca = joblib.load(pca_path)
else:
    pca = PCA(n_components=0.99, svd_solver="full")
    pca.fit(X)
    joblib.dump(pca, pca_path)


# @title
from google.colab import output
output.enable_custom_widget_manager()
# --------------------------------------------------------------------- #
# Main viewer class
# --------------------------------------------------------------------- #
class SklearnPCAMeshViewer:
    """
    Viewer for a sklearn.decomposition.PCA trained on flattened mesh vertices.

    PCA must be trained on vectors of length 3N:
        [x1, y1, z1, x2, y2, z2, ..., xN, yN, zN]

    Parameters
    ----------
    pca : sklearn.decomposition.PCA
        Fitted PCA instance.
    faces : (F,3) int array
        Triangle indices of the template mesh.
    """

    def __init__(self, pca, faces):
        self.pca = pca
        self.faces = np.asarray(faces, dtype=np.int32)

        mean_flat = np.asarray(pca.mean_, dtype=np.float64)  # (3N,)
        if mean_flat.ndim != 1 or mean_flat.size % 3 != 0:
            raise ValueError(
                "pca.mean_ must be a flat vector of length 3N (x,y,z per vertex)."
            )

        self.N = mean_flat.size // 3
        self.mean_vertices = mean_flat.reshape(self.N, 3)  # (N,3)

        self.pcs = np.asarray(pca.components_, dtype=np.float64)  # (K,3N)
        self.K = self.pcs.shape[0]
        if self.pcs.shape[1] != 3 * self.N:
            raise ValueError(
                f"pca.components_ shape mismatch: got {self.pcs.shape}, "
                f"expected (K, 3N) with N={self.N}"
            )

        self.eigenvalues = np.asarray(pca.explained_variance_, dtype=np.float64)
        if self.eigenvalues.shape[0] != self.K:
            raise ValueError(
                "explained_variance_ length must match n_components (K)"
            )

    # ----------------------------------------------------------------- #
    # Core deformation
    # ----------------------------------------------------------------- #
    def deformed_vertices(self, k, alpha=3.0, use_sqrt_eig=True):
        """
        Return vertices for PCA mode k at amplitude alpha.

        Parameters
        ----------
        k : int
            PCA mode index (0 <= k < K).
        alpha : float
            Scaling in units of std if use_sqrt_eig=True.
        use_sqrt_eig : bool
            If True, deformation = alpha * sqrt(lambda_k) * pc_k.
            If False, deformation = alpha * pc_k.

        Returns
        -------
        verts : (N,3) ndarray
        """
        pc_k_flat = self.pcs[k]              # (3N,)
        pc_k = pc_k_flat.reshape(self.N, 3)  # (N,3)

        if use_sqrt_eig:
            sigma = np.sqrt(float(self.eigenvalues[k]))
            deformation = alpha * sigma * pc_k
        else:
            deformation = alpha * pc_k

        mesh = o3d.geometry.TriangleMesh()
        mesh.vertices = o3d.utility.Vector3dVector(self.mean_vertices + deformation)
        mesh.triangles = o3d.utility.Vector3iVector(self.faces)
        mesh.compute_vertex_normals()

        return mesh




template_crown_path = "./template_crown.npy"
template_crown = np.load(template_crown_path, allow_pickle=True).item()
faces = template_crown["faces"]


#%%
viewer = SklearnPCAMeshViewer(pca, faces)

# Example reshaping from sklearn PCA
# pca.components_.shape == (K, N*3)
mean_vertices = viewer.mean_vertices.astype(float)#[::10,:]
K = pca.components_.shape[0]
pcs_flat = pca.components_.reshape(K, mean_vertices.shape[0], 3)  # (K, N, 3)
N = mean_vertices.shape[0]


pcs = pcs_flat.reshape(K, -1, 3)  # -> (K, N, 3)


#%%


mean_vertices = mean_vertices.astype(np.float32)
pcs = pcs.astype(np.float32)
faces = faces.astype(np.int32)
K_show = 10
# Use only the first 5 PCs
K = min(K_show, pcs.shape[0])
pcs = pcs[:K]

# --- 2. Deformation function --------------------------------------

sigma = np.sqrt(viewer.eigenvalues)[:K]

def deform_shape(coeffs):
    """
    coeffs: (K,) slider values
    returns: (N, 3) vertices
    """
    weighted = coeffs[:, None, None] *sigma[:, None, None] * pcs   # (K, N, 3)
    return mean_vertices + weighted.sum(axis=0)  # (N, 3)

# --- 3. Initial mesh ----------------------------------------------

coeffs0 = np.zeros(K, dtype=np.float32)
verts0 = deform_shape(coeffs0)

i, j, k = faces.T

mesh = go.Mesh3d(
    x=verts0[:, 0],
    y=verts0[:, 1],
    z=verts0[:, 2],
    i=i,
    j=j,
    k=k,
            color="lightblue",
            # --- LIGHTING ---
            lighting=dict(
                ambient=0.4,
                diffuse=0.9,
                specular=0.5,
                roughness=0.3,
                fresnel=0.1,
            ),
            lightposition=dict(
                x=0,
                y=0,
                z=-1.0  # light from above
            ),

            flatshading=False,
            opacity=0.4,

)

fig = go.FigureWidget(data=[mesh], layout=go.Layout(
    width=400,
    height=400,
    scene=dict(
        aspectmode="data",
        xaxis=dict(visible=False),
        yaxis=dict(visible=False),
        zaxis=dict(visible=False),
    ),
    margin=dict(l=0, r=0, t=0, b=0),
        scene_camera=dict(
        eye=dict(x=-0.002, y=-0.018, z=2.135),
        center=dict(x=0, y=0, z=0),
        up=dict(x=0, y=0, z=1),
    )))
fig.update_layout(
    width=400,
    height=400,
    scene=dict(
        aspectmode="data",
        xaxis=dict(visible=False),
        yaxis=dict(visible=False),
        zaxis=dict(visible=False),
    ),
    margin=dict(l=0, r=0, t=0, b=0),
        scene_camera=dict(
        eye=dict(x=-0.002, y=-0.018, z=2.135),
        center=dict(x=0, y=0, z=0),
        up=dict(x=0, y=0, z=1),
    )
)

# --- 4. Create sliders (only first 5 PCs) -------------------------

sliders = []
for idx in range(K):
    sliders.append(
        FloatSlider(
            value=0.0,
            min=-2.0,
            max=2.0,
            step=0.25,
            description=f"PC {idx+1}",
            continuous_update=False,
            layout={"width": "400px"},
        )
    )

# --- 5. Update callback -------------------------------------------

def update_mesh(*args):
    coeffs = np.array([s.value for s in sliders], dtype=np.float32)
    verts = deform_shape(coeffs)
    with fig.batch_update():
        fig.data[0].x = verts[:, 0]
        fig.data[0].y = verts[:, 1]
        fig.data[0].z = verts[:, 2]

for s in sliders:
    s.observe(update_mesh, names="value")

reset_btn = Button(description="Reset", button_style='warning')

def on_reset_clicked(b):
    for s in sliders:
        s.value = 0.0   # triggers update_mesh automatically

reset_btn.on_click(on_reset_clicked)

# --- 6. Display ---------------------------------------------------
#
#display(HBox([fig, VBox(sliders)]))

ui = HBox([VBox([reset_btn] + sliders), fig])

display(ui)